# Общая информация

atom — позволякт писать кроссплатформенно на js

## Термины
Конкатенация — объединение строк

Предикат — высказывание, в которое можно подставлять аргументы. То, что даёт ответ TRUE или FALSE, называется предикатом

Постфиксный — значение вернется перед выполненеим операции

Префиксное — значение вернется после выполнения операции

Нотация — система условных обозначений. Соглашение об именовании.

-- Оператор инкрементирования

++ Оператор декрементирования

`` - биктики. Обратные кавычки являются интерполяцией

Выражения expression — числа, функции возвращающие значения

Инструкция statements — циклы, условия

void — выражение, которое должно быть вычислено, без возвращения результата. Можно использовать для самовызывающейся функции.

Бинарные операции — с двумя операндами

Унарные операции — с одним операндом 

Коммутативный закон — от перестановки мест слагаемых сумма не меняется.

моветон — дурной тон.

# Block

синтаксис деструктуризации — позволяет извлекать данные из массивов и литералы объектов.

delete — не удаляет переменные объявленные var

… - Spread syntax. Раскладывает на элементы. Для arr или obj.

Оператор this.

Побитовые операторы — для нулей и единиц.

Лексическая область видимости (Lexical scoping) — поиск значений на текущей области, если не найден, то поиск продолжается на уровне выше и т. д. 

«Лексический» - видимость задается исключительно исходным кодом.

Окружение (environment) — область памяти, куда записываются значения из областей видимости.

Замыкание — это функция и окружение. Функция замкнула некоторую информацию из области видимости. Функция сохранила в себе информацию из области видимости, которая по идее должна была исчезнуть.

Фигурные скобки { } задают новую локальную область видимости

## Типизация
Типизация — типы значений в языке

js — слабая типизация и типизация у него динамическая(код проверяется на типизацию в момент исполнения в браузере)

Тип undefined — в него входит только undefined

undefined — семантически должна генерировать программа, но не программист.

typeof null;          // "object"

typeof undefined;     // "undefined"

null == undefined;     // true

typeof NaN;     // 'number'

Статическая типизацией считается язык программирования, которая обрабатывается на типы на компиляторе до интерпретатора.

## Отдельный блок

Инструкция — это единица исполнения.

Для машин есть корректный код или некорректный.

Uncaught TypeError: undefined is not a function (Uncaught — непойманный)

Литерал — безымянная константа. Фиксированное значение.

\ - не выводится, если ничего не экранирует

\n — перевод строки

\r\n — для виндовс

Интерполяция — преобразованный. Нахождение неизвестных значений функций по известным значениям.

Метод .raw позволяет не экранировать строку, а вывести в исходном виде все символы

Unicode — это единый стандарт кодирования для всех символов

UTF-8, UTF-16, UTF-32 и т.п. — это варианты кодировок, основанные на Unicode.

## Типы данных

Числы — number и bigint - примитивные типы

тип Object — на его базе массивы, даты и другие

undefined — отсутсвие значения


## Обозначения в подсказках vs code
[] - в сигнатуре обозначают необязательность параметров

[, …] - бессчетное коли-во параметров

~Стандартные библиотеки - поставляются вместе с javascript

Свойства — предназначен для данных, используется через точку

Методы — функции внутри свойств

Методы и свойства — выражения, поэтому их можно комбинировать

Данные преобразовываются через обертку object, поэтому у примитывных типов данных имеются внутри свойства со значениями, которые невозможно перезаписать.

Методы возвращают новое значение, потому что примитывные типы данных неизменяемы

## Сборки
системы сборки — (бандлер) webpack — заточенный для сборки приложения

менеджер задач — gulp

## Настройка и подключение webpack и bootstrap

https://bootstrap-4.ru/docs/5.2/getting-started/webpack/

Примитивные типы данных нельзя изменить — например строки


## Операторы

арифметические операции приоритетнее логических

&& - в математичекой логике называют конъюнкцией

|| — «ИЛИ» (дизъюнкция)

оператор сравнения можно использовать только для 2-х операндов

0, '' (пустая строка), undefined, NaN, null приводятся к false

!! - можно поменять тип данного на тип boolean

|| - возвращает первое значение являющееся true

&& - возвращает последний true, либо первый false

if принимает выражение-предикат

Если в if одна строчка кода, то {} можно не писать

startsWith() - метод проверяет наинается ли строка с указанным значением

Тернарный оператор в тернарный оператор и будет дичь — категорически нельзя так делать, усложняется понимание кода

## switch / case
switch — используется для проверки значений в конкретной переменной

case — используется со строгим равенством ===

break или return - точка останова

## Циклы
Агрегация — присоединение элементов в одну систему

Цикл можно остановить с return
инкремент и декремент изменяют значение переменной
использовать префиксный или постфиксные варианты, где нет разницы какой использовать
постфиксный  x++ - сначала возвращает значение, потом изменяет переменную

for — использовать когда количество итерации известно

модули — имена констант и функции уникальны только в пределах файла

## Ссылочные типы - block of htmlacademy

объекты являются ссылочными типами

любая переменная определенная объектом в другой переменной, ссылается на один и тот же объект

сделано это для оптимизации оперативной памяти, потому что js занимает оперативную память у компьютера пользователя

кроме примитивов все остальное ссылочный тип

объект и массив — разница в упорядоченности

## Объекты - block of htmlacademy
даже идентичные  объекты никогда не будут равны при равенстве
reduce — метод перебора массивов с некоторыми плюшками
foreach заменяет for i
в map нужен return — потому что создает новый массив
манкипатчинг — библиотека, которая меняет, например, стандартное поведение определнных методов js. Из-за чего старый код нужно переделывать.
У глобального Object есть object с методами, например Object.keys()
.keys — ключи
.value — значениям
.entries — ключи значений. Получится массив, массивов
.assign — склеивает объекты в целевой объект. Если ключи одинаковые, то перезапишет от объекта, который передавался аргументом правее. Дочерний объект в объекте переносит в новый объект ссылкой.
Для копирования объекта нет встроенных методов, есть только склеивание.
?деструктуризация

## декомпозиция / деструктуризация

this контекст — на примере объекта, выводит содержимое объекта, при обращений функции как метода через точку, получается выводит контекст объекта слева. Особенность: если обращается объекту к ключу с объектом, то контекст this не имеет доступа к главному объекту.

Деструктуризация - это особый синтаксис, позволяющий извлекать значения из объекта и записывать их в новые переменные с минимумом кода
пример 
const {key1, key2} = obj;
необходимо задавать переменные по названию ключей. Возможно к переменной добавить значение по умолчанию, в случае отсутствия ключа в объекте.

Декомпозировать — целое разделение на части

Остаточные параметры (rest parametrs) — например для функции добавляется … троеточие и название переменной arg, получится ...arg. Позволяет принимать бесчетное кол-во аргументов функции. Получает в виде массива. И добавлять остаточный параметр всегда нужно в конец.

Arguments в функции —позволяет получить все переданные аргуметы. Массивоподбный, но не массив, потому что не имеет методов и невозможно доставать часть элементов, только все. Особенность: стрелочные функции не имеют arguments.

Оператор расширения - ...arg например. Перебирает итерируемые объекты, например строку, массивы. Раскладывает по символам, элементам. Удобно использовать вместо цикла.

## IIFE 
IIFE (Immediately Invoked Function Expression) — функция выполняется сразу после ее определения.

## область видимости
у модульных скриптов ограничена область видимость своим скриптом, т. е. Переменные не могут быть установлены глобавльно

блочная область видимости — поведение внутри условий например, как понимаю, то что обернуто в фиг. Скобки {}
функциональная область видимости — поведение внутри функции
Модульная область видимости инкапсулирует модули
 лексической области видимости или статическая область видимости

при замыкании блок кода всегда имеет доступ ко внешним переменным, пример в лексической области видимости 

## Замыкания

лексическое окружение(LexicalEnvironment) — скрытый объект. Состоит из двух частей:
1) Environment Record - место где хранятся переменные в виде свойства, this и многое др.
2) Ссылка на внешнее лексическое окружение
Особенности: у глобального лексического окружения нет ссылки на внешнее окружение, поэтому null

function declaration — инициализируется при при создании лексического окружения, поэтому функцию можно вызвать в любой строчке кода.
При каждом вызове функции создается уникальное лексическое окружение.
старые переменные нигде не сохраняются.
[[Environment]] — присутсвует у всех функции в JavaScript. Является скрытым свойством. Автоматически запоминают, где были созданы. Содержит ссылку на внешнее окружение.
Замыкание — это функция, которая запоминает внешние переменные и может получить к ним доступ.
Все функции являются замыканиями. Исключение Синтаксис "new Function"

После того как функция выполняется, оно самоудаляется(ощищается), его переменные и сама функция становятся не доступными. Если в любом элементе присутствует лексическое окружение к определенной функции, то она сохранеяется и не ощищается, пока на нее больше ничего не будет ссылаться.
V8 движке есть особоенность оптимизации. При debaggere переменная внутри функции становится недоступными, когда отрабатывает функция объявленная в переменную.

## Hoisting

hoisting(поднятие)

функции и переменные поднимаются на верхний уровень при обработке js.

Сначала поднимается объевление переменной на верхний уровень со значением undefined, затем происходит инициализация с присвоением указанного значения к данной переменной.
Любая необъявленная переменная становится видимой глобальной, в том числе, когда используется внутри функции.
'use strict' — устраняет проблемы выше

взрыв мозга. Имеется ввиду объявление с одинаковым названием.
Назначение переменных имеет приоритет перед объявлением функции.
Объявление функции имеет приоритет перед объявлением переменной.
Необходимо объявлять и инициализировать переменные перед их использованием.

«Поднятие» переменных (hoisting) — это когда переменная определяется без одной из приставок var, let, const. Если такое случается, то переменная становится глобальной и записывается к var.
Если переменная с var вызывается до ее объявления, то результат будет undefined. А у let и const упадет в ошибку referrer error.
